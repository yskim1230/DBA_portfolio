# SQL 성능 튜닝 및 리뷰 운영 표준 (SQL Server / MySQL / MariaDB)

## 0. 목적 및 적용 범위

* **목적:** 운영 장애(락/대기/복제지연)와 비용(스캔/정렬/임시테이블)을 줄이기 위해, SQL 작성·리뷰·배포 시 지켜야 할 **공통 표준**을 정의한다.
* **적용 범위:** SQL Server, MySQL, MariaDB 기반의 모든 서비스 쿼리(온라인 트랜잭션, 배치, 리포트 포함).
* **원칙:** “감”으로 판단하지 않는다. **실행계획 + IO/시간 + Rows(추정/실측)** 으로 증빙한다.

---

## 1. 핵심 정의 (팀 공통 언어)

* **SARGable:** 인덱스가 조건식을 이용해 **범위 탐색(Seek/Range Scan)** 가능한 형태.
* **스캔 리스크:** 인덱스가 있어도 조건이 비-SARGable이면 **Index Scan/Full Scan**으로 기울어 비용 폭증 가능.
* **중간 결과 폭발:** 조인/집계 전에 필터링이 부족해 중간 행 수가 급증하는 현상.
* **증빙 3종:** (1) 실행계획 (2) IO/시간 (3) 행 수(추정/실측)

---

## 2. 표준 규칙 (Do / Don’t)

### 2.1 WHERE 조건 (SARGable 표준)

**DO**

* 날짜/시간 조건은 **범위 조건**을 표준으로 한다.

```sql
WHERE CreatedAt >= '2026-01-18'
  AND CreatedAt <  '2026-01-19'
```

* 비교/조인 컬럼의 **데이터 타입을 일치**시킨다(암묵 변환 금지).
* OR가 인덱스 경로를 망치면 **UNION ALL 분해**를 우선 검토한다.

**DON’T**

* 컬럼에 함수/연산/형변환 적용 금지(원칙).

```sql
WHERE CONVERT(date, CreatedAt) = '2026-01-18'  -- 금지(대부분)
WHERE DATE(CreatedAt) = '2026-01-18'          -- 금지(대부분)
WHERE UPPER(UserId) = 'KIM'                   -- 금지(대부분)
```

### 2.2 LIKE / 검색

**DO**

* 접두 검색이 가능하면 `LIKE 'abc%'`로 제한한다.
* “포함 검색”이 요구사항이면, Full-Text/검색엔진/검색 전용 인덱스 등 **검색 설계**를 검토한다.

**DON’T**

* `LIKE '%abc%'`를 습관적으로 사용 금지(필요 시 사유+대안+증빙 필수).

### 2.3 JOIN / EXISTS / NOT EXISTS

**DO**

* EXISTS/NOT EXISTS는 금지 아님. **조인 키 인덱스 유무**가 핵심이다.
* 조인 전에 필터/프리-집계로 **먼저 줄이고 조인**한다.
* 조인 키 컬럼 타입/콜레이션을 맞춰 암묵 변환을 제거한다.

**DON’T**

* EXISTS가 느리면 EXISTS 탓으로 결론내리지 않는다. 인덱스/통계/조건식을 먼저 점검한다.
* 중복을 DISTINCT로 덮지 않는다(중복 원인 제거 우선).

### 2.4 DISTINCT / GROUP BY

**DO**

* DISTINCT는 필요 시 허용하되, **중복 원인(조인 조건/모델)**을 우선 제거한다.
* SELECT 컬럼을 최소화하여 정렬/해시 비용을 통제한다.

**DON’T**

* DISTINCT “금지” 같은 단정 규정 금지(현실과 불일치). 대신 “사용 기준”을 둔다.

### 2.5 MIN/MAX / TOP/LIMIT

**DO**

* 인덱스 정렬을 활용해 “끝/앞 1건” 패턴으로 작성한다.
* SQL Server:

```sql
SELECT TOP (1) Col FROM T WHERE ... ORDER BY Col DESC;
```

* MySQL/MariaDB:

```sql
SELECT Col FROM T WHERE ... ORDER BY Col DESC LIMIT 1;
```

### 2.6 페이징

**DO**

* 대용량 목록은 Keyset Pagination을 표준으로 권장한다.

```sql
WHERE Id > @LastId
ORDER BY Id
```

**DON’T**

* 큰 OFFSET 기반 페이징을 금지(뒤 페이지로 갈수록 선형 악화).

### 2.7 대량 변경(UPDATE/DELETE)

**DO**

* 대량 변경은 배치(Chunk) 처리 + 짧은 트랜잭션을 표준으로 한다.
* 인덱스가 없는 조건으로 대량 삭제/갱신 금지(먼저 인덱스/전략 수립).

**DON’T**

* 한 방에 대량 삭제/갱신해서 락/로그/복제지연 유발 금지.

---

## 3. 리뷰 게이트(필수 산출물)

### 3.1 리뷰에 반드시 포함할 것

* **쿼리 목적 및 기대 결과**(중복/NULL 처리 포함)
* **대상 테이블 규모/인덱스 현황**(키 컬럼 및 조건 컬럼)
* **증빙 3종**

  1. 실행계획(전/후 또는 현 상태)
  2. IO/시간(전/후)
  3. Rows(추정/실측)

### 3.2 DB별 최소 증빙 템플릿

**SQL Server**

* `SET STATISTICS IO, TIME ON` 출력(전/후)
* Actual Execution Plan 캡처(Seek/Scan, Sort/Hash, Spill, Implicit Conversion 표시)

**MySQL/MariaDB**

* `EXPLAIN` 또는 가능 시 `EXPLAIN ANALYZE` 결과(전/후)
* slow query log 또는 실행시간/rows examined/rows sent 기준(가능한 범위)

---

## 4. 리뷰 체크리스트 15개 (필수 점검)

1. 결과 정합성(중복/누락/NULL)
2. SELECT 최소화(SELECT *)
3. SARGable(함수/변환/연산)
4. 날짜 조건 범위화
5. 타입/콜레이션 일치(암묵 변환 제거)
6. 조인 키 인덱스 유무
7. 조인 전 필터/프리-집계
8. OR 분해 필요성(UNION ALL)
9. LIKE 패턴(접두 가능 여부/포함검색 설계)
10. DISTINCT 사용 사유 및 대안 검토
11. 정렬/집계 비용(파일정렬/임시테이블/스필)
12. 페이징 방식(OFFSET 금지, Keyset 권장)
13. 반복 호출(N+1/루프) 여부
14. 트랜잭션 범위/락 영향
15. 증빙 첨부(플랜/IO/Rows)

---

## 5. 표준 개선 패턴 10선 (요약)

1. 날짜 변환 제거 → 범위 조건
2. 컬럼 함수 제거 → 값 변환/정규화/계산열(필요 시)
3. OR 분해 → UNION ALL
4. LIKE 포함검색 남용 → 접두 검색/검색 설계
5. DISTINCT로 덮기 → EXISTS/조인 구조 개선
6. NOT IN → NOT EXISTS(NULL 안전)
7. 조인 전 줄이기 → 필터/프리-집계 후 조인
8. 큰 OFFSET → Keyset Pagination
9. 그룹별 최신1건 → ROW_NUMBER(윈도우 함수) + 인덱스
10. 대량 변경 한방 → 배치 처리 + 인덱스 전제

---

# 6) 리뷰 코멘트 템플릿 20개

## A. SARGable / 함수/변환

1. “현재 WHERE 조건이 컬럼에 함수/변환을 적용하고 있어 비-SARGable입니다. 인덱스 탐색이 어려우니 범위 조건(>= AND <) 또는 컬럼 기준 비교로 수정 바랍니다. (전/후 IO 첨부 필요)”
2. “암묵 변환(타입 불일치) 가능성이 있습니다. 조인/비교 컬럼의 타입을 일치시키고, 필요하면 파라미터 타입부터 수정 바랍니다.”
3. “`DATE()/CONVERT()`로 날짜를 자르는 방식은 인덱스를 막습니다. 날짜 범위 조건으로 재작성 바랍니다.”

## B. LIKE / 검색

4. “`LIKE '%…%'`는 스캔 유발 가능성이 큽니다. 접두 검색으로 요구사항 조정 가능 여부를 확인하고, 불가하면 FTS/검색 설계 대안을 제시 바랍니다.”
5. “포함 검색 요구사항이면 튜닝이 아니라 검색 설계 이슈입니다. 데이터 규모/갱신 패턴 기준으로 FTS 또는 검색 엔진 도입 검토가 필요합니다.”

## C. OR / UNION ALL

6. “OR 조건으로 인해 최적화가 스캔으로 기울 수 있습니다. 각 조건을 `UNION ALL`로 분해하는 대안을 제시하고 플랜/IO 비교를 첨부 바랍니다.”
7. “OR 분해 시 중복 방지가 필요합니다. 중복이 생기지 않도록 분해 조건을 보완하거나 마지막 중복 제거 전략을 명시 바랍니다.”

## D. JOIN / EXISTS

8. “EXISTS는 금지 대상이 아닙니다. 다만 서브쿼리 조인 키 인덱스가 없으면 급격히 느려질 수 있으니 관련 인덱스 유무/설계를 함께 제시 바랍니다.”
9. “조인 전에 필터링이 부족해 중간 결과가 폭발할 수 있습니다. 먼저 줄이는(필터/프리-집계) 구조로 재작성 검토 바랍니다.”
10. “조인 키 타입/콜레이션 불일치가 의심됩니다. 암묵 변환이 발생하면 인덱스 활용이 크게 떨어지니 타입 정합성부터 맞춰주세요.”

## E. DISTINCT / GROUP BY

11. “DISTINCT는 필요하면 사용 가능합니다. 다만 현재는 중복 원인(조인 조건/카디널리티)을 가리는 용도로 보입니다. 중복 원인을 먼저 제거하고, DISTINCT 필요 여부를 재검토 바랍니다.”
12. “DISTINCT/집계 비용이 큰 편입니다. SELECT 컬럼 최소화 및 인덱스(정렬/그룹 키) 검토를 제안합니다.”

## F. 정렬/집계/스필

13. “ORDER BY/집계로 정렬 비용이 큽니다. 인덱스로 정렬을 대체할 수 있는지(복합 인덱스 순서 포함) 검토 바랍니다.”
14. “정렬/해시가 메모리 초과로 디스크 스필이 발생할 수 있습니다(플랜 상 Spill/Using temporary/filesort 확인). 행 수 감소/인덱스/쿼리 구조 개선이 필요합니다.”

## G. 페이징

15. “OFFSET 기반 페이징은 뒤로 갈수록 선형 악화됩니다. Keyset Pagination으로 전환을 권장합니다(정렬 키/타이브레이커 포함).”
16. “페이징 정렬 키가 유일하지 않으면 페이지 중복/누락이 발생할 수 있습니다. `(CreatedAt, Id)` 같은 안정 키로 보완 바랍니다.”

## H. 대량 변경/트랜잭션/락

17. “대량 UPDATE/DELETE를 한 번에 수행하면 락/로그/복제지연 리스크가 큽니다. 배치 처리(Chunk) + 짧은 트랜잭션으로 수정 바랍니다.”
18. “현재 트랜잭션 범위가 넓어 락 대기 유발 가능성이 있습니다. 트랜잭션 분리 또는 선행 조건 인덱스 적용으로 락 범위를 줄이세요.”
19. “조건 컬럼 인덱스가 없으면 배치 처리도 반복 스캔으로 악화될 수 있습니다. 먼저 조건 컬럼 인덱스/전략부터 제시 바랍니다.”

## I. 증빙 요구

20. “개선 제안은 이해했습니다. 배포 전 최소 증빙(실행계획 + IO/시간 + Rows)을 전/후로 첨부 바랍니다. (SQL Server는 STATISTICS IO/TIME, MySQL/MariaDB는 EXPLAIN/ANALYZE 및 rows examined 포함)”

---

## 7. 운영 적용 규칙(권장)

* **배포 전:** 최소 1회 플랜/IO 증빙 첨부(핵심 쿼리)
* **장애/느림 발생 시:** 상위 N개 쿼리(시간/IO 기준) 추출 → 재현 → 개선 → 증빙 → 회고 기록
* **문서 관리:** 본 표준은 분기 1회 업데이트(실제 장애 사례 반영)

